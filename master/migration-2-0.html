<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8"/>
  <title>Migration Guide v1.1 -&gt; v2.0 | scnlib scanf for modern C++</title>
  <link href="favicon-dark.png" rel="icon" type="image/png"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <meta content="#22272e" name="theme-color"/>
  <link href="poxy/poxy.css" referrerpolicy="no-referrer" rel="stylesheet"/>
  <script src="poxy/poxy.js"></script>
  <script>initialize_theme("dark");</script>
  <meta content="scnlib" name="twitter:title"/>
  <meta content="scnlib" property="og:title"/>
  <meta content="scnlib" itemprop="name"/>
  <meta content="Elias Kosunen" name="author"/>
  <meta content="Elias Kosunen" property="article:author"/>
  <meta content="scanf for modern C++" name="description"/>
  <meta content="scanf for modern C++" name="twitter:description"/>
  <meta content="scanf for modern C++" property="og:description"/>
  <meta content="scanf for modern C++" itemprop="description"/>
  <meta content="telephone=no" name="format-detection"/>
  <meta content="Poxy v0.16.0" name="generator"/>
  <meta content="strict-origin-when-cross-origin" name="referrer"/>
</head>
<body class="poxy-has-toc">
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a class="m-col-t-8 m-col-m-none m-left-m" href="index.html" id="m-navbar-brand">scnlib <span class="m-thin">scanf for modern C++</span></a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a class="m-doc-search-icon" href="#search" onclick="return showSearch()" title="Search"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z" id="m-doc-search-icon-path"></path>
        </svg></a>
        <a href="#navigation" id="m-navbar-show" title="Show navigation"></a>
        <a href="#" id="m-navbar-hide" title="Hide navigation"></a>
      </div>
      <div class="m-col-t-12 m-show-m m-col-m-none m-right-m" id="m-navbar-collapse">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="namespaces.html">Namespaces</a></li>
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="modules.html">Modules</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="4">
            <li><a href="pages.html">Pages</a></li>
            <li><a class="poxy-icon repo github poxy-external" href="https://github.com/eliaskosunen/scnlib" target="_blank" title="View on GitHub"><svg id="poxy-icon-repo" version="1.1" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg"><path d="M25,1.23a24.37,24.37,0,0,0-7.7,47.5C18.51,49,19,48.2,19,47.56s0-2.12,0-4.15c-6.78,1.47-8.21-3.27-8.21-3.27C9.61,37.33,8,36.58,8,36.58c-2.21-1.51.17-1.48.17-1.48a5.12,5.12,0,0,1,3.73,2.51c2.17,3.72,5.7,2.65,7.09,2a5.25,5.25,0,0,1,1.55-3.26c-5.41-.61-11.1-2.7-11.1-12A9.41,9.41,0,0,1,12,17.79a8.75,8.75,0,0,1,.24-6.45s2-.66,6.7,2.49a23.1,23.1,0,0,1,12.2,0c4.66-3.15,6.7-2.49,6.7-2.49A8.75,8.75,0,0,1,38,17.79a9.41,9.41,0,0,1,2.51,6.54c0,9.36-5.7,11.42-11.13,12a5.83,5.83,0,0,1,1.65,4.51c0,3.26,0,5.89,0,6.69,0,.65.44,1.41,1.68,1.17A24.38,24.38,0,0,0,25,1.23Z" fill="currentColor"></path></svg></a></li>
            <li><a class="poxy-icon theme" href="javascript:void(null);" id="poxy-theme-switch" onclick="toggle_theme(); return false;" role="button" title="Toggle dark and light themes"><svg id="poxy-theme-switch-img" version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><circle cx="185.6708" cy="183.8122" fill="currentColor" r="65.625"></circle><path d="M185.6708,87.5622a13.1256,13.1256,0,0,0,13.125-13.125V52.5622a13.125,13.125,0,1,0-26.25,0v21.875A13.1257,13.1257,0,0,0,185.6708,87.5622Z" fill="currentColor"></path><path d="M99.051,115.7519a13.1236,13.1236,0,1,0,18.56-18.56L102.1442,81.726a13.1236,13.1236,0,0,0-18.5595,18.56Z" fill="currentColor"></path><path d="M89.4208,183.8122a13.1257,13.1257,0,0,0-13.125-13.125H54.4208a13.125,13.125,0,0,0,0,26.25h21.875A13.1256,13.1256,0,0,0,89.4208,183.8122Z" fill="currentColor"></path><path d="M99.051,251.8725,83.5847,267.3431a13.1236,13.1236,0,1,0,18.56,18.56l15.4663-15.4706a13.1236,13.1236,0,1,0-18.5595-18.56Z" fill="currentColor"></path><path d="M185.6708,280.0622a13.1258,13.1258,0,0,0-13.125,13.125v21.875a13.125,13.125,0,0,0,26.25,0v-21.875A13.1257,13.1257,0,0,0,185.6708,280.0622Z" fill="currentColor"></path><path d="M272.2907,251.8725a13.1236,13.1236,0,1,0-18.56,18.56l15.4663,15.4706a13.1236,13.1236,0,1,0,18.56-18.56Z" fill="currentColor"></path><path d="M330.0458,183.8122a13.1257,13.1257,0,0,0-13.125-13.125h-21.875a13.125,13.125,0,0,0,0,26.25h21.875A13.1256,13.1256,0,0,0,330.0458,183.8122Z" fill="currentColor"></path><path d="M263.0109,119.5971a13.0824,13.0824,0,0,0,9.28-3.8452l15.4663-15.4663a13.1236,13.1236,0,1,0-18.56-18.56L253.7312,97.1923a13.125,13.125,0,0,0,9.28,22.4048Z" fill="currentColor"></path><path d="M456.9379,401.6714a63.97,63.97,0,0,1-14.9963,7.2055c-19.6448,6.5283-41.8787,2.9566-58.1439-9.8523a68.9311,68.9311,0,0,1-10.835-10.8339c-12.8088-16.2663-16.3806-38.5-9.8523-58.1471a63.8444,63.8444,0,0,1,7.2077-14.9931,8.8036,8.8036,0,0,0-10.1172-13.3034,87.5188,87.5188,0,1,0,110.0372,110.04A8.8,8.8,0,0,0,456.9379,401.6714Z" fill="currentColor"></path></svg></a></li>
            <li class="m-show-m"><a class="m-doc-search-icon" href="#search" onclick="return showSearch()" title="Search"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path"></use>
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          Migration Guide v1.1 -&gt; v2.0
        </h1>
        <nav class="m-block m-default poxy-toc" id="poxy-toc">
          <h3>Contents</h3>
          <ul>
            <li><a href="#m2-cpp17">C++17 required</a></li>
            <li><a href="#headers">Header files changed</a></li>
            <li><a href="#m2-scan_prefix">"scan_" prefix added to many names</a></li>
            <li><a href="#m2-scan_arg_passing">Argument passing and return value</a></li>
            <li><a href="#m2-indirect">No more "indirect" ranges: revamped source range error handling</a></li>
            <li><a href="#m2-range-requirements">Relaxed source range requirements</a></li>
            <li><a href="#m2-ownership">Returned ranges do not take ownership</a></li>
            <li><a href="#m2-files">Files removed</a></li>
            <li><a href="#m2-scanner-specialize">Specializing scn::scanner changed</a></li>
            <li><a href="#m2-scan_usertype">scn::scan_usertype removed</a></li>
            <li><a href="#m2-parser">scn::*_parser removed</a></li>
            <li><a href="#m2-istream-operator">Including &lt;scn/istream.h&gt; no longer enables custom scanning for types with an operator&gt;&gt; by default</a></li>
            <li><a href="#m2-scan_localized">scn::scan_localized renamed to scn::scan</a></li>
            <li><a href="#m2-lists">List operations removed</a></li>
            <li><a href="#m2-ignore-getline">scn::ignore and scn::getline removed</a></li>
            <li><a href="#m2-encoding">Encoding is always Unicode</a></li>
          </ul>
        </nav>
<p>For v2.0, the library was rewritten and redesigned in its entirety. The new design is more focused and powerful, and closer to <code><a class="m-doc-external poxy-cppreference poxy-external" href="http://en.cppreference.com/w/cpp/utility/format/format.html" target="_blank">std::<wbr/>format</a></code> than previously.</p><p>This guide isn't exhaustive, because the changes are very extensive, but should be enough to get you started.</p><section id="m2-cpp17"><h2><a href="#m2-cpp17">C++17 required</a></h2><p>v1 required C++11 in order to compile. v2, at least at this point, requires C++17.</p></section><section id="headers"><h2><a href="#headers">Header files changed</a></h2><p>The base header is renamed from <code>&lt;scn/scn.h&gt;</code> in v1 to <code>&lt;scn/scan.h&gt;</code> in v2.</p><p>To get support for <code><a class="m-doc poxy-injected poxy-external poxy-cppreference" href="https://en.cppreference.com/w/cpp/language/types#Character_types" target="_blank">wchar_t</a></code> input, include <code>&lt;scn/xchar.h&gt;</code>. This is done to ease compile times.</p></section><section id="m2-scan_prefix"><h2><a href="#m2-scan_prefix">"scan_" prefix added to many names</a></h2><p>To prepare for standardization, in v2, many names have the prefix <code>scan_</code>, or otherwise indicate being related to scanning.</p><p>Changes include:</p><table class="m-table"><thead><tr><th>v1</th><th>v2</th></tr></thead><tbody><tr><td><code>scn::error</code></td><td><code><a class="m-doc" href="classscn_1_1scan__error.html">scn::<wbr/>scan_error</a></code></td></tr><tr><td><code>scn::basic_arg</code>, <code>scn::basic_args</code>, <code>scn::arg_store</code></td><td><code><a class="m-doc" href="classscn_1_1basic__scan__arg.html">scn::<wbr/>basic_scan_arg</a></code>, <code><a class="m-doc" href="classscn_1_1basic__scan__args.html">scn::<wbr/>basic_scan_args</a></code>, <code><a class="m-doc" href="classscn_1_1scan__arg__store.html">scn::<wbr/>scan_arg_store</a></code></td></tr><tr><td><code>scn::basic_context</code></td><td><code><a class="m-doc" href="classscn_1_1basic__scan__context.html">scn::<wbr/>basic_scan_context</a></code>, <code>scn::scan_context</code></td></tr><tr><td><code>scn::basic_parse_context</code>, <code>scn::parse_context</code></td><td><code><a class="m-doc" href="classscn_1_1basic__scan__parse__context.html">scn::<wbr/>basic_scan_parse_context</a></code>, <code>scn::scan_parse_context</code></td></tr></tbody></table></section><section id="m2-scan_arg_passing"><h2><a href="#m2-scan_arg_passing">Argument passing and return value</a></h2><p>The largest change is in how values are returned from <code><a class="m-doc" href="group__scan.html#gab691a605c387f6510a9c2559b026af04">scn::<wbr/>scan</a></code> and other scanning functions.</p><p>In v1, values were passed to <code><a class="m-doc" href="group__scan.html#gab691a605c387f6510a9c2559b026af04">scn::<wbr/>scan</a></code> by lvalue reference as out parameters. The return value was used to get information about the leftover input data, and about possible errors.</p><pre class="m-code"><span class="k">int</span> <span class="n">i</span><span class="p">;</span>
<span class="nn">std</span><span class="o">::</span><span class="nc">string</span> <span class="n">str</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan</span><span class="p">(</span><span class="s">"123 input"</span><span class="p">,</span> <span class="s">"{} {}"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span></pre><p>In v2, the values are returned from <code><a class="m-doc" href="group__scan.html#gab691a605c387f6510a9c2559b026af04">scn::<wbr/>scan</a></code>, wrapped in an <code><a class="m-doc" href="classscn_1_1expected.html">scn::<wbr/>expected</a></code>. The types of the arguments are given in an explicit template parameter list, instead of being deduced from the given arguments.</p><pre class="m-code"><span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan</span><span class="o">&lt;</span><span class="k">int</span><span class="p">,</span> <span class="nn">std</span><span class="o">::</span><span class="nc">string</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"123 input"</span><span class="p">,</span> <span class="s">"{} {}"</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">-&gt;</span><span class="nf">values</span><span class="p">();</span></pre><p>The <code>result</code> value above is truthy when the operation was successful. Use <code>result-&gt;range()</code> to get a <code>subrange</code> over the unparsed input, <code>result-&gt;begin()</code> and <code>result-&gt;end()</code> to get the beginning and the end of that range, respectively, and <code>result-&gt;values()</code> to access the parsed values through a <code><a class="m-doc-external poxy-cppreference poxy-external" href="http://en.cppreference.com/w/cpp/utility/tuple.html" target="_blank">std::<wbr/>tuple</a></code>. If only a single value is read, <code>result-&gt;value()</code> can be used to access it directly. If <code>result</code> contains an error, use <code>result.error()</code> to access it.</p></section><section id="m2-indirect"><h2><a href="#m2-indirect">No more "indirect" ranges: revamped source range error handling</a></h2><p>The notion of "indirect" ranges from v1 is removed in v2. Indirect ranges were source ranges, the value type of which was <code><a class="m-doc" href="classscn_1_1expected.html">scn::<wbr/>expected</a>&lt;CharT&gt;</code>, instead of <code>CharT</code>. This was to enable source ranges to report their own errors to the library, and for it to pass them forward to the user. In v2, the value type of the source range must either be <code>char</code> or <code><a class="m-doc poxy-injected poxy-external poxy-cppreference" href="https://en.cppreference.com/w/cpp/language/types#Character_types" target="_blank">wchar_t</a></code>.</p><p>This approach was arguably against the principles of Ranges, and made a lot of things more complicated than they needed to be.</p><p>In v2, the separation of I/O and input parsing is more clearly separated. scnlib is not intended to be an I/O library, and that it shan't try to be. In the optimal case, if I/O needs to be performed to fetch the data to be passed to scnlib, that is done by the user, to ensure proper behavior and error recovery. Also, when scnlib is given plain contiguous strings as input, instead of more complicated ranges, a number of optimizations are enabled.</p><pre class="m-code"><span class="nn">std</span><span class="o">::</span><span class="nc">string</span> <span class="n">input</span><span class="p">;</span>
<span class="nn">std</span><span class="o">::</span><span class="nf">getline</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>

<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">);</span></pre><p>If doing your own I/O isn't possible, or is for some reason unfeasible, some other options are available:</p><p>1) A <code>FILE*</code> can be given as the source to <code><a class="m-doc" href="group__scan.html#gab691a605c387f6510a9c2559b026af04">scn::<wbr/>scan</a></code>, or in the case of <code>stdin</code>, <code><a class="m-doc" href="group__scan.html#ga3d9bf446b9f090ff62dd6bd3bf42e4a2">scn::<wbr/>input</a></code> can be used.</p><p>1) A <code>scn::basic_istreambuf_view</code>/<code>scn::basic_istreambuf_subrange</code> can be given as a source range to <code><a class="m-doc" href="group__scan.html#gab691a605c387f6510a9c2559b026af04">scn::<wbr/>scan</a></code>. These types wrap an arbitrary <code><a class="m-doc-external poxy-cppreference poxy-external" href="http://en.cppreference.com/w/cpp/io/basic_istream.html" target="_blank">std::<wbr/>basic_istream</a></code>/<code><a class="m-doc-external poxy-cppreference poxy-external" href="http://en.cppreference.com/w/cpp/io/basic_streambuf.html" target="_blank">std::<wbr/>basic_streambuf</a></code>. This can be useful, if you already have a <code><a class="m-doc-external poxy-cppreference poxy-external" href="http://en.cppreference.com/w/cpp/io/basic_istream.html" target="_blank">std::<wbr/>basic_istream</a></code>, and don't want to accidentally read anything extra from the stream, like with <code><a class="m-doc-external poxy-cppreference poxy-external" href="http://en.cppreference.com/w/cpp/io/cin.html" target="_blank">std::<wbr/>cin</a></code>.</p><pre class="m-code"><span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">my_file</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">);</span></pre><p>2) Signal errors like any other range signals them: by reaching the end prematurely, or with exceptions (discouraged). If using a custom user-provided range, this is likely the only option.</p><pre class="m-code"><span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan</span><span class="o">&lt;</span><span class="k">int</span><span class="p">,</span> <span class="k">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">custom_source_range</span><span class="p">,</span> <span class="s">"{} {}"</span><span class="p">);</span>
<span class="c1">// result can be true, if both the int and the double could be scanned,</span>
<span class="c1">// but the given range reached an error condition.</span>
<span class="c1">// We need to do the checking ourselves through custom_source_range, through whatever mechanism it provides</span>
<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">custom_source_range</span><span class="p">.</span><span class="nf">good</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">-&gt;</span><span class="nf">values</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Alternatively, if custom_source_range throws on error</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan</span><span class="o">&lt;</span><span class="k">int</span><span class="p">,</span> <span class="k">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">custom_source_range</span><span class="p">,</span> <span class="s">"{} {}"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">-&gt;</span><span class="nf">values</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">custom_source_range_error</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span></pre></section><section id="m2-range-requirements"><h2><a href="#m2-range-requirements">Relaxed source range requirements</a></h2><p>The set of allowed source ranges to be given to <code><a class="m-doc" href="group__scan.html#gab691a605c387f6510a9c2559b026af04">scn::<wbr/>scan</a></code> is increased in v2, compared to v1.</p><p>In v1, a range was scannable, if it was bidirectional, and default and move constructible.</p><p>In v2, the range needs to just be a <code>forward_range</code>, and movable.</p></section><section id="m2-ownership"><h2><a href="#m2-ownership">Returned ranges do not take ownership</a></h2><p>In v1, the lifetime semantics of the range returned from <code><a class="m-doc" href="group__scan.html#gab691a605c387f6510a9c2559b026af04">scn::<wbr/>scan</a></code> were complicated. Usually, the returned range was a view over the given range, i.e. reference semantics were used. But, sometimes, if the range was an rvalue container (or anything else that didn't model <code>borrowed_range</code>), the return value contained that range, i.e. ownership was taken.</p><pre class="m-code"><span class="c1">// v1: reference semantics</span>
<span class="k">int</span> <span class="n">i</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan</span><span class="p">(</span><span class="s">"123 456"</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="c1">// result contains a string_view over the given string literal</span>

<span class="c1">// v1: reference semantics</span>
<span class="nn">std</span><span class="o">::</span><span class="nc">string</span> <span class="n">source</span><span class="p">{</span><span class="s">"123 456"</span><span class="p">};</span>
<span class="k">int</span> <span class="n">i</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="c1">// result contains a string_view over source</span>

<span class="c1">// v1: ownership semantics</span>
<span class="k">int</span> <span class="n">i</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan</span><span class="p">(</span><span class="nn">std</span><span class="o">::</span><span class="nc">string</span><span class="p">{</span><span class="s">"123 456"</span><span class="p">},</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="c1">// result contains a <a class="m-doc poxy-injected poxy-external poxy-cppreference" href="https://en.cppreference.com/w/cpp/string/basic_string" target="_blank">std::string</a></span></pre><p>In v2, the semantics are clearer: a view (<code>subrange</code>) over the given range is always returned. If that view would dangle, <code>ranges::dangling</code> is returned instead.</p><pre class="m-code"><span class="c1">// v2: reference semantics (no change)</span>
<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"123 456"</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">);</span>
<span class="c1">// result-&gt;begin() points to the given string literal</span>

<span class="c1">// v2: reference semantics (no change)</span>
<span class="nn">std</span><span class="o">::</span><span class="nc">string</span> <span class="n">source</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">);</span>
<span class="c1">// result-&gt;begin() points to source</span>

<span class="c1">// v2: dangling</span>
<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">(</span><span class="nn">std</span><span class="o">::</span><span class="nc">string</span><span class="p">{</span><span class="s">"123 456"</span><span class="p">},</span> <span class="s">"{}"</span><span class="p">);</span>
<span class="c1">// result-&gt;begin() is of type scn::ranges::dangling, the given <a class="m-doc poxy-injected poxy-external poxy-cppreference" href="https://en.cppreference.com/w/cpp/string/basic_string" target="_blank">std::string</a> has gone out of scope and been destroyed</span></pre><p>In other words, in v2, <code><a class="m-doc" href="group__scan.html#gab691a605c387f6510a9c2559b026af04">scn::<wbr/>scan</a></code> always returns an iterator pointing to the given range. If that's not possible without dangling, it returns <code>scn::ranges::dangling</code> instead.</p></section><section id="m2-files"><h2><a href="#m2-files">Files removed</a></h2><p>In v1, scnlib provided support for reading files with <code>scn::file</code>, <code>scn::owning_file</code>, and <code>scn::mapped_file</code>. These caused the library to grow in size, blurred its focus, and were the source of many bugs.</p><p>In v2, these have been removed. If you need to read from a file, either do your own I/O and give <code><a class="m-doc" href="group__scan.html#gab691a605c387f6510a9c2559b026af04">scn::<wbr/>scan</a></code> a string, or use <code><a class="m-doc" href="group__scan.html#gab691a605c387f6510a9c2559b026af04">scn::<wbr/>scan</a></code> with a <code>FILE*</code>. If you need to use memory mapped files, do the mapping yourself, and give <code><a class="m-doc" href="group__scan.html#gab691a605c387f6510a9c2559b026af04">scn::<wbr/>scan</a></code> a view into the mapped memory.</p><p>In v2, <code>scn::cstdin()</code> and <code>scn::wcstdin()</code> have been removed. For reading from stdin, use <code><a class="m-doc" href="group__scan.html#ga3d9bf446b9f090ff62dd6bd3bf42e4a2">scn::<wbr/>input</a></code> and <code><a class="m-doc" href="group__scan.html#ga2860ab85b607d9cafcbf268e4f57db35">scn::<wbr/>prompt</a></code>, or <code><a class="m-doc" href="group__scan.html#gab691a605c387f6510a9c2559b026af04">scn::<wbr/>scan</a></code> with <code>stdin</code>.</p><pre class="m-code"><span class="c1">// v1:</span>
<span class="k">int</span> <span class="n">i</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">input</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="c1">// or</span>
<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan</span><span class="p">(</span><span class="nn">scn</span><span class="o">::</span><span class="nf">cstdin</span><span class="p">(),</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

<span class="c1">// v2:</span>
<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">input</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"{}"</span><span class="p">);</span>
<span class="c1">// or</span>
<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">);</span></pre></section><section id="m2-scanner-specialize"><h2><a href="#m2-scanner-specialize">Specializing scn::scanner changed</a></h2><p>In v1, <code><a class="m-doc" href="structscn_1_1scanner.html">scn::<wbr/>scanner</a></code> took the type it was used for as a template parameter. Inside it, <code>parse()</code> and <code><a class="m-doc" href="group__scan.html#gab691a605c387f6510a9c2559b026af04">scan()</a></code> returned a <code>scn::error</code>.</p><pre class="m-code"><span class="k">struct</span> <span class="nc">int_and_double</span> <span class="p">{</span>
    <span class="k">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">double</span> <span class="n">d</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="nn">scn</span><span class="o">::</span><span class="nc">scanner</span><span class="o">&lt;</span><span class="n">int_and_double</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ParseCtx</span><span class="o">&gt;</span>
    <span class="n">error</span> <span class="nf">parse</span><span class="p">(</span><span class="n">ParseCtx</span><span class="o">&amp;</span> <span class="n">pctx</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Context</span><span class="o">&gt;</span>
    <span class="n">error</span> <span class="nf">scan</span><span class="p">(</span><span class="n">int_and_double</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Context</span><span class="o">&amp;</span> <span class="n">ctx</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="p">};</span></pre><p>In v2, <code><a class="m-doc" href="structscn_1_1scanner.html">scn::<wbr/>scanner</a></code> also takes in the character type of the source range. This is consistent with <code><a class="m-doc-external poxy-cppreference poxy-external" href="http://en.cppreference.com/w/cpp/utility/format/formatter.html" target="_blank">std::<wbr/>formatter</a></code>. The character type defaults to <code>char</code>.</p><p><code>parse()</code> and <code><a class="m-doc" href="group__scan.html#gab691a605c387f6510a9c2559b026af04">scan()</a></code> return a <code><a class="m-doc" href="structscn_1_1scan__expected.html">scn::<wbr/>scan_expected</a>&lt;iterator&gt;</code>.</p><p><code>parse()</code> should be <code>constexpr</code>, to support compile-time format string checking.</p><pre class="m-code"><span class="k">struct</span> <span class="nc">int_and_double</span> <span class="p">{</span>
   <span class="k">int</span> <span class="n">i</span><span class="p">;</span>
   <span class="k">double</span> <span class="n">d</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CharT</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nn">scn</span><span class="o">::</span><span class="nc">scanner</span><span class="o">&lt;</span><span class="n">int_and_double</span><span class="p">,</span> <span class="n">CharT</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ParseCtx</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="k">auto</span> <span class="nf">parse</span><span class="p">(</span><span class="n">ParseCtx</span><span class="o">&amp;</span> <span class="n">pctx</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">scan_expected</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ParseCtx</span><span class="o">::</span><span class="n">iterator</span><span class="o">&gt;</span><span class="p">;</span>
 
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Context</span><span class="o">&gt;</span>
    <span class="k">auto</span> <span class="nf">scan</span><span class="p">(</span><span class="n">int_and_double</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Context</span><span class="o">&amp;</span> <span class="n">ctx</span><span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">scan_expected</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Context</span><span class="o">::</span><span class="n">iterator</span><span class="o">&gt;</span><span class="p">;</span>

<span class="p">};</span></pre></section><section id="m2-scan_usertype"><h2><a href="#m2-scan_usertype">scn::scan_usertype removed</a></h2><p>In v1, <code>scn::scan_usertype</code> could be used to make scanning values of custom types easier. This helper function was necessary, because the scanning context had complex logic concerning the source range. In v2, this has been removed, because of the new tuple-return API, and because the context no longer deals with complicated ranges.</p><pre class="m-code"><span class="c1">// v1</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Context</span><span class="o">&gt;</span>
<span class="n">error</span> <span class="nf">scan</span><span class="p">(</span><span class="n">int_and_double</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Context</span><span class="o">&amp;</span> <span class="n">ctx</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan_usertype</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="nf">range</span><span class="p">(),</span> <span class="s">"[{}, {}]"</span><span class="p">,</span> <span class="n">val</span><span class="p">.i</span><span class="p">,</span> <span class="n">val</span><span class="p">.</span><span class="n">d</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// v2</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Context</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="nf">scan</span><span class="p">(</span><span class="n">int_and_double</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">Context</span><span class="o">&amp;</span> <span class="n">ctx</span><span class="p">)</span> <span class="k">const</span>
    <span class="o">-&gt;</span> <span class="n">expected</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Context</span><span class="o">::</span><span class="n">iterator</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan</span><span class="o">&lt;</span><span class="k">int</span><span class="p">,</span> <span class="k">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="nf">range</span><span class="p">(),</span> <span class="s">"[{}, {}]"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">unexpected</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="nf">error</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="nn">std</span><span class="o">::</span><span class="nf">tie</span><span class="p">(</span><span class="n">val</span><span class="p">.</span><span class="n">i</span><span class="p">,</span> <span class="n">val</span><span class="p">.</span><span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="n">result</span><span class="o">-&gt;</span><span class="nf">values</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">-&gt;</span><span class="nf">begin</span><span class="p">();</span>
<span class="p">}</span></pre></section><section id="m2-parser"><h2><a href="#m2-parser">scn::*_parser removed</a></h2><p>In v1, there were helper base classes for creating <code>scanner::parse</code>, including <code>scn::empty_parser</code> and <code>scn::common_parser</code>.</p><p>In v2, these are removed. Create your own <code>parse</code> member functions, or reuse already existing <code>scanner</code>s.</p></section><section id="m2-istream-operator"><h2><a href="#m2-istream-operator">Including &lt;scn/istream.h&gt; no longer enables custom scanning for types with an operator&gt;&gt; by default</a></h2><p>In v1, just by including <code>&lt;scn/istream.h&gt;</code>, any type with an <code>operator&gt;&gt;</code> would be automatically <code><a class="m-doc" href="group__scan.html#gab691a605c387f6510a9c2559b026af04">scn::<wbr/>scan</a></code>able.</p><p>In v2, you'll need to explicitly opt in to this behavior for your own types, by creating a <code><a class="m-doc" href="structscn_1_1scanner.html">scn::<wbr/>scanner</a></code>, and inheriting from the <code><a class="m-doc" href="structscn_1_1basic__istream__scanner.html">scn::<wbr/>basic_istream_scanner</a>&lt;CharT&gt;</code> class template.</p><p>This is done to avoid potentially surprising behavior.</p><pre class="m-code"><span class="cp">#include</span> <span class="cpf">&lt;scn/istream.h&gt;</span>

<span class="k">struct</span> <span class="nc">mytype</span> <span class="p">{</span>
    <span class="k">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

    <span class="k">friend</span> <span class="nn">std</span><span class="o">::</span><span class="nc">istream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="nn">std</span><span class="o">::</span><span class="nc">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">,</span> <span class="k">const</span> <span class="n">mytype</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">is</span> <span class="o">&gt;&gt;</span> <span class="n">val</span><span class="p">.</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="n">val</span><span class="p">.</span><span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// v1 would work out of the box:</span>
<span class="n">mytype</span> <span class="n">val</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan</span><span class="p">(</span><span class="s">"123 456"</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

<span class="c1">// v2 requires a scanner definition</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">CharT</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nn">scn</span><span class="o">::</span><span class="nc">scanner</span><span class="o">&lt;</span><span class="n">mytype</span><span class="p">,</span> <span class="n">CharT</span><span class="o">&gt;</span> <span class="o">:</span> <span class="k">public</span> <span class="nn">scn</span><span class="o">::</span><span class="nc">basic_istream_scanner</span><span class="o">&lt;</span><span class="n">CharT</span><span class="o">&gt;</span> <span class="p">{};</span>

<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan</span><span class="o">&lt;</span><span class="n">mytype</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"123 456"</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">);</span></pre></section><section id="m2-scan_localized"><h2><a href="#m2-scan_localized">scn::scan_localized renamed to scn::scan</a></h2><p>In v1, to use a <code><a class="m-doc-external poxy-cppreference poxy-external" href="http://en.cppreference.com/w/cpp/locale/locale.html" target="_blank">std::<wbr/>locale</a></code> in scanning, the function <code>scn::scan_localized</code> had to be used.</p><p>In v2, this function is part of the <code><a class="m-doc" href="group__scan.html#gab691a605c387f6510a9c2559b026af04">scn::<wbr/>scan</a></code> overload set.</p><pre class="m-code"><span class="c1">// v1</span>
<span class="k">int</span> <span class="n">i</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan_localized</span><span class="p">(</span><span class="n">locale</span><span class="p">,</span> <span class="s">"42"</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

<span class="c1">// v2;</span>
<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">locale</span><span class="p">,</span> <span class="s">"42"</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">);</span></pre></section><section id="m2-lists"><h2><a href="#m2-lists">List operations removed</a></h2><p>In v1, there were <code>scn::scan_list</code> and <code>scn::scan_list_ex</code>, that could be used to scan multiple values of the same type into a container.</p><p>In v2, these have been removed. Either scan each value manually, or use the new (experimental) range scanning functionality, in <code>&lt;scn/ranges.h&gt;</code>.</p><pre class="m-code"><span class="c1">// v1</span>
<span class="nn">std</span><span class="o">::</span><span class="nc">vector</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan_list</span><span class="p">(</span><span class="s">"123 456 abc"</span><span class="p">,</span> <span class="n">vec</span><span class="p">);</span>
<span class="c1">// vec == [123, 456]</span>
<span class="c1">// result.range() == " abc"</span>
<span class="c1">// NOTE: result.error() == invalid_scanner_value (because of "abc")</span>

<span class="c1">// v2</span>
<span class="nn">std</span><span class="o">::</span><span class="nc">vector</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{};</span>
<span class="k">auto</span> <span class="n">input</span> <span class="o">=</span> <span class="nn">scn::ranges</span><span class="o">::</span><span class="n">subrange</span><span class="p">{</span><span class="nn">std</span><span class="o">::</span><span class="nc">string_view</span><span class="p">{</span><span class="s">"123 456 abc"</span><span class="p">}};</span>

<span class="k">while</span> <span class="p">(</span><span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">vec</span><span class="p">.</span><span class="nf">push_back</span><span class="p">(</span><span class="n">result</span><span class="o">-&gt;</span><span class="nf">value</span><span class="p">());</span>
    <span class="n">input</span> <span class="o">=</span> <span class="n">result</span><span class="o">-&gt;</span><span class="nf">range</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// vec == [123, 456]</span>
<span class="c1">// input == " abc"</span>

<span class="c1">// or, if the source range is in the correct format</span>
<span class="c1">// (how std::format would output it)</span>
<span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="nn">scn</span><span class="o">::</span><span class="nf">scan</span><span class="o">&lt;</span><span class="nn">std</span><span class="o">::</span><span class="nc">vector</span><span class="o">&lt;</span><span class="k">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="s">"[123, 456]"</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">);</span>
<span class="c1">// result-&gt;value() == [123, 456]</span></pre></section><section id="m2-ignore-getline"><h2><a href="#m2-ignore-getline">scn::ignore and scn::getline removed</a></h2><p>In v2, <code>scn::ignore</code> can be replaced with simple range operations, like <code>scn::ranges::views::drop_while</code>.</p><p><code>scn::getline</code> can be replaced with <code><a class="m-doc" href="group__scan.html#gab691a605c387f6510a9c2559b026af04">scn::<wbr/>scan</a>&lt;<a class="m-doc-external poxy-cppreference poxy-external" href="http://en.cppreference.com/w/cpp/string/basic_string.html" target="_blank">std::<wbr/>string</a>&gt;(..., "{:[^\n]}")</code>.</p></section><section id="m2-encoding"><h2><a href="#m2-encoding">Encoding is always Unicode</a></h2><p>In v1, when scanning in non-localized mode, the input was assumed to be Unicode (UTF-8, UTF-16, or UTF-32, based on the character type), and whatever the locale specified in localized mode. Because of the limited character encoding handling support provided by the standard library, this was buggy.</p><p>In v2, all inputs are assumed to be Unicode, despite what has been set in a possibly supplied locale.</p></section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">…</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input autocomplete="off" autofocus="autofocus" disabled="disabled" id="search-input" name="q" placeholder="Loading …" spellcheck="false" type="search"/>
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div class="m-text m-dim m-text-center" id="search-help">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">↓</span>
            / <span class="m-label m-dim">↑</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div class="m-text m-warning m-text-center" id="search-notfound">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v2.js"></script><script>install_mcss_search_shim();</script>
<script async="async" src="searchdata-v2.js"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        
<a class="poxy-external" href="https://github.com/eliaskosunen/scnlib" target="_blank">GitHub</a>
• <a class="poxy-external" href="https://github.com/eliaskosunen/scnlib/issues" target="_blank">Report an issue</a>
• <a class="poxy-external" href="https://github.com/eliaskosunen/scnlib/blob/dev/LICENSE" target="_blank">License</a>
• <a download="" href="scnlib.tagfile.xml" target="_blank" type="text/xml">Doxygen tagfile</a>
<br/><br/>
Site generated using <a class="poxy-external" href="https://github.com/marzer/poxy/" target="_blank">Poxy</a>

      </div>
    </div>
  </div>
</nav></footer>


</body></html>